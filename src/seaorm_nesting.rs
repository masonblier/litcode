//- Nested partial views in the SeaORM database framework
//- --
//- A discussion of nested views in SeaORM Rust ORM Database client
//- By [masonblier](https://github.com/masonblier) 2025-07-22

//- [SeaORM](https://www.sea-ql.org/SeaORM/) is an object-relational mapping library for Sqlite, MySQL,
//- and PostgreSQL for the Rust programming languages. It's major advantages are its `async`/`await`
//- tooling and abstraction over the subtle differences between the three major SQL databases. It also
//- comes with with a full GraphQL abstraction framework called [Seaography](https://github.com/SeaQL/seaography).
//- SeaORM is great for backend Rust applications and integrates easily with any web server, such as the
//- fully async [Axum](https://github.com/tokio-rs/axum) framework.
//=

//- SeaORM has full support for migrations and a tool to generate `Entity` classes (models) from the
//- database schema, eliminating the need to define the data structures in multiple places. It also
//- supports relational mapping suchs as one-to-one, one-to-many, and many-to-many through foreign keys.

//- In this example, I define an `Employee` table with some basic info about a company, and a foreign key
//- creating a many-to-one relationship between `Employee` and `Company` records. SeaORM updates the database
//- using this migration, and with the `sea-orm-cli generate entity` command, `Entity` classes for use in
//- application code are generated automatically, including relationship definitions and a variety of
//- query building helpers
#[async_trait::async_trait]
impl MigrationTrait for Migration {
    async fn up(&self, manager: &SchemaManager) -> Result<(), DbErr> {
        manager
            .create_table(
                Table::create()
                    .table(Employee::Table)
                    .if_not_exists()
                    .col(pk_auto(Employee::Id))
                    .col(ColumnDef::new(Employee::Name)
                        .string().not_null().unique_key())
                    .col(ColumnDef::new(Employee::CompanyId).integer().not_null())
                    .foreign_key(
                        ForeignKey::create()
                            .name("fk-employee-company_id")
                            .from(Employee::Table, Employee::CompanyId)
                            .to(Company::Table, Company::Id),
                    )
                    .to_owned(),
            )
            .await
    }
}

#[derive(DeriveIden)]
pub enum Employee {
    Table,
    Id,
    Name,
    Company
}

//- Partial Views
//- ==
//- One of its lesser-known features are it's partial `View` classes, which allow querying of a subset of fields
//- from a table. This allows getting only the rows you want to use in a given context, such as showing
//- public information to an end user without revealing private information. These partial views are
//- derived using the `DerivePartialModel` and `FromQueryResult` declarative macros.
// from entity_views/company.rs
#[derive(DerivePartialModel, FromQueryResult, Serialize)]
#[sea_orm(entity = "Entity")]
pub struct CompanyView {
    pub id: i32,
    pub name: String,
    pub address: String,
}

//- This can be extended to relational models as well with the `nested` attribute macro. SeaORM can
//- figure out based on the object definition how other tables need to be queried and build the
//- necessary JOIN clauses to pull all the data in a single query, reducing `N+1` data transfers.
use super::CompanyView;

#[derive(DerivePartialModel, FromQueryResult, Serialize)]
#[sea_orm(entity = "Entity")]
pub struct EmployeeView {
    pub id: i32,
    pub name: String,
    #[sea_orm(nested)]
    pub company: CompanyView,
}

//- These partial views can be queried with the `.into_partial_model()` method in the query builder.
let rows: Vec<EmployeeView> = Employee::find()
    .join_as(
        JoinType::InnerJoin,
        employee::Relation::Company.def(),
        "company",
    )
    .into_partial_model()
    .all(&db).await?;

//- Unfortunately, this is where SeaORM currently falls short of a magic wand. When querying partial
//- objects through a `join_as`, the query builder can't automatically determined the names for columns
//- queried from other tables. I currently fix this by creating views specialized for each query, with
//- attribute macros defining the column name generated by the join query.
#[derive(DerivePartialModel, FromQueryResult, Serialize)]
#[sea_orm(entity = "Entity")]
pub struct EmployeeCompanyView {
    #[sea_orm(from_alias = "company_id")]
    pub id: i32,
    #[sea_orm(from_alias = "company_name")]
    pub name: String,
    #[sea_orm(from_alias = "company_address")]
    pub address: String,
}

//- While this is often necessary to do anyways, due to the different column subset requirements of
//- complex queries, it can become unwieldy. When querying a third nested `View`, the table name of
//- both parent tables are included in the field alias name. This `View` can't be used in any other query.
#[derive(DerivePartialModel, FromQueryResult, Serialize)]
#[sea_orm(entity = "Entity")]
pub struct EmployeeCompanyCountryView {
    #[sea_orm(from_alias = "company_country_id")]
    pub id: i32,
    #[sea_orm(from_alias = "company_country_name")]
    pub name: String,
}

//- Despite this, [SeaORM](https://www.sea-ql.org/SeaORM/) is a well capable database layer for almost any application. The advantages of
//- using a higher-level abstraction to easily swap the database backend is essential for automating
//- integration tests or building libraries deployed to a client's existing setup. Hopefully in future
//- versions, nested relationships can be revamped to provide even more automatic code generation, leaving
//- the tedious work of low-level type mangling to the compiler.
